<!DOCTYPE html>
<html>
<head>
    <title>bind-call-and-apply-in-javascript</title>  
    
</head>
<body>
    <h2>Hello</h2>
  
    <script type="text/javascript">
        //https://variadic.me/posts/2013-10-22-bind-call-and-apply-in-javascript.html

        // Set up a simple object to use as "context"
        var context = { foo: "bar" };

        // A function that uses a reference to a variable called "foo" on the "this" context.
        function returnFoo() {
            return this.foo;
        }

        // This variable does not exist on scope, so is undefined.
        returnFoo();
        console.log(returnFoo());   //undefined

        // But if we bind the function to the context. The name variable is now in scope.
        // That's what Function.prototype.bind does. Since returnFoo is a function, it inherits the function prototype.
        var bound = returnFoo.bind(context);
        bound();
        console.log(bound());   //bar

        // There are many ways of attaching a context to a function.
        // Call and apply let you call a function with a given context.
        returnFoo.call(context);
        returnFoo.apply(context);
        console.log(returnFoo.call(context));   //bar
        console.log(returnFoo.apply(context));  //bar

        // Including adding the function to the object.
        context.returnFoo = returnFoo;
        context.returnFoo();
        console.log(context.returnFoo());   //bar

        context.anynameFoo = returnFoo;
        context.anynameFoo();
        console.log(context.anynameFoo());   //bar

        //
        // Now let's get freaky with it.
        //

        // Array.prototype has this sweet method called slice. You call it on an array, and it gives you a copy of the array from start index to end index (exclusive).
        [1, 2, 3].slice(0, 1);
        console.log([1, 2, 3].slice(0, 1));     //[1]

        // So we grab slice and assign it to a local variable.
        var slice = Array.prototype.slice;
        // slice is now "unbound". As Array.prototype.slice usually acts on the context it is given, or "this", it will no longer work.
        slice(0, 1);                            //[]
        console.log(slice(0, 1));
        slice([1, 2, 3], 0, 1);
        console.log(slice([1, 2, 3], 0, 1));    //[]
        
        // But if we recall apply and call, they let us supply a context.
        slice.call([1, 2, 3], 0, 1);
        console.log(slice.call([1, 2, 3], 0, 1));       //[1]
        // Apply works like call, but takes arguments as an array.
        slice.apply([1, 2, 3], [0, 1]);
        console.log(slice.apply([1, 2, 3], [0, 1]));    //[1]


        // It sure gets old using .call though. What if we bind it? That's right! Let's bind "call" to slice. Yes.
        slice = Function.prototype.call.bind(Array.prototype.slice); //bind the sweet array slice method to the local variable slice
        // Now slice uses the first argument as context. So the local slice works on context without call, NICE!
        slice([1, 2, 3], 0, 1);
        console.log(slice([1, 2, 3], 0, 1));    //[1]

        //
        // Pretty cool huh? But I got one last thing for you.
        //

        // Let's put "bind" itself through the same process we did "slice".
        var bind = Function.prototype.call.bind(Function.prototype.bind);

        // Wrap your mind around that. Think about it. What does it do? 
        // We are flipping "call", returning a function that takes a function and a context and returning a fully bound function.

        // Bringing back our original example.
        var context = { foo: "bar" };
        function returnFoo() {
            return this.foo;
        }
        // And using our new amazing "bind".
        var amazing = bind(returnFoo, context);        
        amazing();
        console.log(amazing()); //bar 

        // Reference: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind

    </script>
</body>
</html>
